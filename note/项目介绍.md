**Telegram 智能视频库系统架构终极方案**。

-----

# 1\. 项目愿景与架构概览

## 1.1 项目目标

构建一个运行在 Mac mini M4 上的个人私有媒体中心，实现：

1.  **自动化采集：** 监听 Telegram 订阅频道，自动下载视频。
2.  **存储均衡：** 自动管理多个外接硬盘空间，实现“多盘合一”的自动化存储。
3.  **智能识别（IoC模式）：** Java 掌握策略，Python 提供算力。利用 CLIP 模型（M4 MPS 加速）根据动态 Prompt 识别视频高亮片段。
4.  **可视化管理：** Web 端管理 Prompt 策略、查看时间轴高亮、一键无损剪辑。

## 1.2 系统拓扑图

```text
[ 外接硬盘池 (Shared Storage) ]
(/Volumes/SSD, /Volumes/HDD...)
       ▲             ▲
       | (读/写)      | (只读)
       |             |
+------+------+   +--+------------+
| Python Worker|   | Java Backend | <=====> [ MySQL Database ]
| (算力/采集)  |---| (业务/控制)  | (唯一的数据所有者, 仅Java连接)
+------+------+   +--+------------+
       ^             ^
       | HTTP/JSON   | HTTP/REST
       |             |
       +-------------+
              |
       [ Web Frontend ]
       (Vue 3 SPA)
```

-----

# 2\. 技术栈选型

| 模块 | 技术组件 | 核心理由 |
| :--- | :--- | :--- |
| **硬件** | Mac mini M4 (16G) | 利用统一内存和 Neural Engine (MPS) 加速 AI。 |
| **Java 后端** | Spring Boot 3 + JPA | 负责业务逻辑、数据一致性维护（代替外键）、文件流服务。 |
| **Python 后端** | FastAPI + Telethon + PyTorch | Telethon 协议支持完善；PyTorch 支持 macOS MPS 加速。 |
| **数据库** | MySQL 8.0 (`utf8mb4`) | **无外键设计**，仅由 Java 端连接。 |
| **前端** | Vue 3 + Video.js | 响应式 UI，可视化进度条。 |
| **工具** | FFmpeg | 本地安装，用于无损剪辑 (`-c copy`)。 |

-----

# 3\. 模块功能详解

## 3.1 Java 核心服务 (Spring Boot)

**角色：大脑 (Brain)**。

1.  **元数据中心 (Metadata Center):**
      * 管理视频 ID、标题、来源信息。
      * **逻辑完整性维护：** 在删除视频时，由 Java 代码负责先删除关联的 AI 片段（因为没有数据库级联删除）。
      * **路径映射：** 将逻辑 `node_id` 转换为物理绝对路径。
2.  **策略管理器 (Strategy Manager):**
      * 管理 `Prompt Profiles`（提示词方案）。
      * 维护 `Channel Config`，决定哪个频道用哪套 AI 方案。
3.  **AI 编排器 (AI Orchestrator):**
      * 决定何时分析视频（自动/手动）。
      * **任务下发：** 组装请求（文件绝对路径 + Prompt 列表）发送给 Python。
      * **结果处理：** 接收 Python 返回的分析结果并入库。
4.  **媒体服务器 (Media Server):**
      * 提供支持 `Range` 请求的流媒体接口（实现拖拽播放）。
      * 封装 `ProcessBuilder` 调用本地 FFmpeg。

## 3.2 Python 算力节点 (FastAPI + Telethon)

**角色：手与眼 (Worker)**。无状态，不连接数据库。

1.  **采集监听器 (The Listener):**
      * 启动时调用 Java 接口获取需监听的 Channel ID 列表。
      * 保持 MTProto 长连接，捕获 `NewMessage`。
2.  **存储负载均衡器 (Disk Load Balancer):**
      * 实时扫描 `config` 中配置的所有硬盘剩余空间。
      * **算法：** 贪婪策略，每次下载前选择剩余空间最大的硬盘写入。
3.  **AI 推理引擎 (Inference Engine):**
      * 加载 CLIP 模型（开启 `device="mps"`）。
      * 提供 HTTP 接口，被动接收 Java 的分析指令。

## 3.3 Web 前端 (Vue 3)

**角色：控制台 (Dashboard)**。

1.  **Prompt 实验室:** 创建/修改识别方案（如“日剧模式”：`["opening song", "credits"]`）。
2.  **智能播放器:** 在进度条上渲染高亮片段；点击跳转；点击“保存片段”。
3.  **资源管理:** 视频列表、手动触发 AI 分析、频道规则配置。

-----

# 4\. 数据库设计 (无外键版)

**设计原则：**

1.  **移除所有 `FOREIGN KEY` 约束**。
2.  **保留索引 (`KEY`/`INDEX`)** 以确保查询性能。
3.  **字符集：** `utf8mb4`。
4.  **逻辑关联：** 依靠字段命名（如 `video_id`）在代码层面维护关联。

## 4.1 AI 策略配置表 (`prompt_profiles`)

存储 Web 端管理的提示词方案。

```sql
CREATE TABLE `prompt_profiles` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL COMMENT '方案名 (如: Jpop现场)',
  `prompts_json` json NOT NULL COMMENT '核心：提示词数组 ["stage", "light"]',
  `threshold` decimal(3,2) DEFAULT 0.25 COMMENT '默认阈值',
  `sample_rate` int(11) DEFAULT 1 COMMENT '采样率(fps)',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  `updated_at` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='AI策略配置';
```

## 4.2 频道规则表 (`channel_configs`)

定义频道与 AI 方案的绑定关系。

```sql
CREATE TABLE `channel_configs` (
  `telegram_chat_id` bigint(20) NOT NULL COMMENT '频道ID',
  `channel_name` varchar(255) DEFAULT NULL COMMENT '备注名',
  `target_folder` varchar(100) DEFAULT 'Uncategorized' COMMENT '归档目录名',
  `prompt_profile_id` bigint(20) DEFAULT NULL COMMENT '逻辑外键: 关联 prompt_profiles.id',
  `auto_analyze` tinyint(1) DEFAULT 0 COMMENT '下载后自动分析?',
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`telegram_chat_id`),
  KEY `idx_prompt_profile` (`prompt_profile_id`) -- 保留索引用于JOIN查询
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='频道规则';
```

## 4.3 视频资产表 (`video_assets`)

核心主表，存储物理位置映射。

```sql
CREATE TABLE `video_assets` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(500) DEFAULT NULL,
  
  -- 存储映射
  `storage_node` varchar(50) NOT NULL COMMENT '存储节点ID (如 ssd_1)',
  `relative_path` varchar(1000) NOT NULL COMMENT '相对路径',
  `file_size_bytes` bigint(20) DEFAULT 0,
  `duration_seconds` decimal(10,2) DEFAULT 0.00,
  
  -- 来源信息
  `telegram_chat_id` bigint(20) NOT NULL,
  `telegram_message_id` bigint(20) NOT NULL,
  `post_date` datetime DEFAULT NULL,
  
  -- 状态 (0:Pending, 1:Ready, 2:Analyzing, 3:Analyzed)
  `status` tinyint(4) DEFAULT 0,
  `ingest_time` datetime DEFAULT CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tg_source` (`telegram_chat_id`, `telegram_message_id`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='视频资产';
```

## 4.4 智能分段表 (`video_ai_segments`)

存储分析结果。Java 代码在删除 `video_assets` 记录前，需先 `DELETE FROM video_ai_segments WHERE video_id = ?`。

```sql
CREATE TABLE `video_ai_segments` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `video_id` bigint(20) NOT NULL COMMENT '逻辑外键: 关联 video_assets.id',
  `prompt_profile_id` bigint(20) DEFAULT NULL COMMENT '记录生成时用的策略ID',
  
  `label` varchar(100) NOT NULL COMMENT '识别到的标签',
  `start_time` decimal(10,2) NOT NULL,
  `end_time` decimal(10,2) NOT NULL,
  `confidence` decimal(5,4) DEFAULT NULL,
  
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_video_id` (`video_id`) -- 保留索引用于快速查询某视频的所有片段
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='AI分段结果';
```

## 4.5 剪辑产物表 (`generated_clips`) (可选)

```sql
CREATE TABLE `generated_clips` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `source_video_id` bigint(20) NOT NULL COMMENT '逻辑外键: 关联 video_assets.id',
  `storage_node` varchar(50) NOT NULL,
  `relative_path` varchar(1000) NOT NULL,
  `created_at` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_source` (`source_video_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

-----

# 5\. 接口协议设计 (Internal API)

## 5.1 Python -\> Java (上报数据)

**接口：** `POST /api/internal/ingest`
**描述：** Python 下载完成，请求入库。
**Payload:**

```json
{
  "storage_node": "ext_hdd_1",
  "relative_path": "JPOP/live_2025.mp4",
  "file_size": 1048576,
  "duration": 120.5,
  "telegram_chat_id": -10012345678,
  "telegram_message_id": 999,
  "caption": "Yorushika Live #Jpop",
  "post_date": "2025-08-03T12:00:00Z"
}
```

## 5.2 Java -\> Python (下发任务)

**接口：** `POST /api/worker/analyze`
**描述：** Java 计算好绝对路径和 Prompts，命令 Python 执行。
**Payload:**

```json
{
  "file_absolute_path": "/Volumes/Seagate_4TB/Archive/JPOP/live_2025.mp4",
  "prompts": ["singer on stage", "crowd cheering", "guitar close up"],
  "threshold": 0.28,
  "sample_rate": 1
}
```

**Response:**

```json
{
  "status": "success",
  "segments": [
    { "label": "singer on stage", "start": 10.5, "end": 45.0, "score": 0.88 }
  ]
}
```

## 5.3 启动同步

**接口：** `GET /api/internal/channels/monitor-list`
**描述：** Python 启动时拉取监听列表。
**Response:** `[-10012345678, -10098765432]`

-----

# 6\. 核心业务流程

## 6.1 采集与负载均衡流程

1.  **Event:** Telethon 监听到视频消息。
2.  **Load Balance:** Python 遍历配置的硬盘，计算剩余空间，选出 `best_node` (如 `ssd_1`)。
3.  **Download:** Python 下载文件至 `/Volumes/SSD1/JPOP/video.mp4`。
4.  **Notify:** Python 调用 `POST /ingest`。
5.  **Save:** Java 存入 `video_assets` 表。

## 6.2 动态 AI 分析流程 (IoC模式)

1.  **Trigger:**
      * **自动:** Java 入库时发现 `channel_configs.auto_analyze = 1`。
      * **手动:** Web 端点击“重新分析”。
2.  **Prepare:** Java 查询 `prompt_profiles` 表，获取 `prompts_json`。
3.  **Path Resolve:** Java 读取 `application.yml`，将 `ssd_1` + `relative_path` 拼成 Mac 绝对路径。
4.  **Call:** Java 调用 Python `analyze` 接口。
5.  **Inference:** Python 使用 MPS 运行 CLIP，返回 `segments`。
6.  **Store:** Java **显式删除**该视频旧的 segments（因无外键，需代码保证），保存新数据，更新状态为 `Analyzed`。

-----

# 7\. 部署配置 (Configuration)

## 7.1 Java `application.yml`

```yaml
app:
  storage:
    nodes:
      ssd_1: /Volumes/Samsung_T7/Media
      hdd_1: /Volumes/Seagate_4TB/Archive
      hdd_2: /Volumes/WD_Element/Archive
  python-worker:
    url: http://localhost:8000
```

## 7.2 Python `config.json`

```json
{
  "storage_nodes": {
    "ssd_1": "/Volumes/Samsung_T7/Media",
    "hdd_1": "/Volumes/Seagate_4TB/Archive",
    "hdd_2": "/Volumes/WD_Element/Archive"
  },
  "java_backend_url": "http://localhost:8080"
}
```

此方案移除了所有数据库层面的外键约束，依靠 Java 严谨的业务逻辑代码来维护数据关系，提供了最大的灵活性和性能表现。